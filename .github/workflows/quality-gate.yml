name: "Quality Gate"

on:
  pull_request:
    branches: [ "main", "develop" ]

# Cancel previous runs if a new one is triggered
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  quality-gate:
    name: "quality-gate"
    runs-on: ubuntu-latest
    timeout-minutes: 15
    
    # Least-privilege permissions
    permissions:
      # Required to read repository contents
      contents: read
      # Required to write PR comments
      pull-requests: write
    
    # Output coverage percentage for other jobs to use
    outputs:
      coverage-percentage: ${{ steps.coverage.outputs.percentage }}
      
    steps:
    - name: Checkout repository
      uses: actions/checkout@v5

    - name: Setup Node.js
      uses: actions/setup-node@v5
      with:
        node-version: '18'

    - name: Setup pnpm
      run: npm install -g pnpm@10.12.4

    - name: Cache pnpm dependencies
      uses: actions/cache@v4
      with:
        path: ~/.pnpm-store
        key: ${{ runner.os }}-pnpm-${{ hashFiles('**/pnpm-lock.yaml') }}
        restore-keys: |
          ${{ runner.os }}-pnpm-

    - name: Install dependencies
      run: pnpm install --frozen-lockfile

    - name: Run tests with coverage
      run: pnpm run test:coverage

    - name: Parse coverage report
      id: coverage
      run: |
        # Check if coverage report exists
        if [ ! -f "coverage/coverage-summary.json" ]; then
          echo "❌ Coverage report not found at coverage/coverage-summary.json"
          exit 1
        fi
        
        # Extract total coverage percentage from JSON report
        # Vitest coverage-summary.json format: {"total":{"lines":{"pct":85.5}}}
        COVERAGE=$(node -p "
          try {
            const coverage = require('./coverage/coverage-summary.json');
            Math.round(coverage.total.lines.pct);
          } catch (e) {
            console.error('Error parsing coverage:', e.message);
            process.exit(1);
          }
        ")
        
        echo "Coverage: ${COVERAGE}%"
        echo "percentage=${COVERAGE}" >> $GITHUB_OUTPUT
        
        # Set environment variables for later steps
        echo "COVERAGE_PERCENTAGE=${COVERAGE}" >> $GITHUB_ENV
        
        # Define threshold
        THRESHOLD=90
        echo "COVERAGE_THRESHOLD=${THRESHOLD}" >> $GITHUB_ENV
        
        # Check if coverage meets threshold
        if [ "$COVERAGE" -ge "$THRESHOLD" ]; then
          echo "✅ Coverage ${COVERAGE}% meets threshold of ${THRESHOLD}%"
          echo "COVERAGE_STATUS=✅ PASSED" >> $GITHUB_ENV
          echo "COVERAGE_COLOR=28a745" >> $GITHUB_ENV
        else
          echo "❌ Coverage ${COVERAGE}% below threshold of ${THRESHOLD}%"
          echo "COVERAGE_STATUS=❌ FAILED" >> $GITHUB_ENV
          echo "COVERAGE_COLOR=d73a49" >> $GITHUB_ENV
          exit 1
        fi

    - name: Upload coverage reports
      uses: actions/upload-artifact@v4
      with:
        name: coverage-reports
        path: |
          coverage/
        retention-days: 30
        # Include coverage info in artifact
        if-no-files-found: error

    - name: Comment PR with coverage results
      uses: actions/github-script@v8
      # Only comment on PRs, not pushes
      if: github.event_name == 'pull_request'
      with:
        script: |
          const fs = require('fs');
          const coverage = process.env.COVERAGE_PERCENTAGE;
          const threshold = process.env.COVERAGE_THRESHOLD;
          const status = process.env.COVERAGE_STATUS;
          const color = process.env.COVERAGE_COLOR;

          // Parse detailed coverage data
          let detailedCoverage = '';
          try {
            const coverageData = JSON.parse(fs.readFileSync('coverage/coverage-summary.json', 'utf8'));

            // Extract file-level coverage (excluding 'total')
            const files = Object.entries(coverageData)
              .filter(([filename]) => filename !== 'total')
              .map(([filename, data]) => ({
                file: filename.replace(process.cwd() + '/', ''),
                lines: data.lines.pct,
                functions: data.functions.pct,
                branches: data.branches.pct,
                statements: data.statements.pct
              }))
              .sort((a, b) => a.lines - b.lines); // Sort by line coverage, lowest first

            // Create detailed table
            if (files.length > 0) {
              detailedCoverage = `

          <details>
          <summary>📊 Detailed Coverage by File</summary>

          | File | Lines | Functions | Branches | Statements |
          |------|-------|-----------|----------|------------|`;

              files.forEach(file => {
                const lineIcon = file.lines === 100 ? '✅' : file.lines >= 90 ? '⚠️' : '❌';
                const funcIcon = file.functions === 100 ? '✅' : file.functions >= 90 ? '⚠️' : '❌';
                const branchIcon = file.branches === 100 ? '✅' : file.branches >= 90 ? '⚠️' : '❌';
                const stmtIcon = file.statements === 100 ? '✅' : file.statements >= 90 ? '⚠️' : '❌';

                detailedCoverage += `
          | \`${file.file}\` | ${lineIcon} ${file.lines}% | ${funcIcon} ${file.functions}% | ${branchIcon} ${file.branches}% | ${stmtIcon} ${file.statements}% |`;
              });

              detailedCoverage += `

          **Legend:** ✅ = 100% | ⚠️ = 90-99% | ❌ = <90%

          </details>`;
            }
          } catch (error) {
            console.log('Could not parse detailed coverage:', error.message);
            detailedCoverage = `

          <details>
          <summary>📊 View detailed coverage report</summary>

          Coverage artifacts are available for download above.

          </details>`;
          }

          const body = `## 🧪 Test Coverage Report

          | Metric | Value | Status |
          |--------|-------|--------|
          | **Coverage** | \`${coverage}%\` | ${status} |
          | **Threshold** | \`${threshold}%\` | |

          ![Coverage Badge](https://img.shields.io/badge/Coverage-${coverage}%25-${color})

          ${Number(coverage) >= Number(threshold)
            ? '✅ **Quality Gate Passed!** Coverage meets the required threshold.'
            : '❌ **Quality Gate Failed!** Coverage is below the required threshold.'}${detailedCoverage}
          `;
          
          // Find existing coverage comment to update it instead of creating new ones
          const comments = await github.rest.issues.listComments({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
          });
          
          const coverageComment = comments.data.find(comment => 
            comment.body.includes('🧪 Test Coverage Report')
          );
          
          if (coverageComment) {
            // Update existing comment
            await github.rest.issues.updateComment({
              comment_id: coverageComment.id,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            });
            console.log('Updated existing coverage comment');
          } else {
            // Create new comment
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            });
            console.log('Created new coverage comment');
          }